# Documentation

* [Installation](#installation)
* [Prerequisites](#prerequisites)
* [Usage](#usage)
    * [Input](#input)
    * [Options](#options)
    * [Output](#output)
* [Informatic resources](#informatic-resources)
    * [Memory](#memory)
    * [Cpu](#cpu)
* [Examples](#examples)
    * [Standard](#standard)
    * [Slurm](#slurm)
    * [PBS/Torque](#pbstorque)
* [Performance](#performance)
* [Parallel filesystems](#parallel-filesystems)
* [Algorithm](#algorithm)
* [References](#references)


## Installation

Follow the [Installation](INSTALL.md) guidelines to compile and install `mpiBWA`.

## Prerequisites

As `mpiBWA` relies on the Message Passing Interface (MPI) standard, `mpirun` must be available to run the program. Several MPI implementations exist
such as [mpich](https://www.mpich.org/), [open-mpi](https://www.open-mpi.org/) or [IntelÂ® MPI Library](https://software.intel.com/en-us/mpi-library). The `mpirun` program must be available in your PATH.

### Install mpirun on CentOS

* for [open-mpi](https://www.open-mpi.org/): `sudo yum install openmpi openmpi-devel`
* for [mpich](https://www.mpich.org/): `sudo yum install mpich`

### Install mpirun on Ubuntu

* for [open-mpi](https://www.open-mpi.org/): `sudo apt-get install openmpi-bin`
* for [mpich](https://www.mpich.org/): `sudo apt-get install mpich`

## Usage

We have 2 versions of mpiBWA. One version create a unique SAM file and the other sort the output by the chromosoms present in the header. 

To switch of version rename in the `mpiBWA_SOURCES` in the file src/Makefile.am with `mainParallelByChromosome.c`

After installation Makefile creates 2 binaries: mpiBWA and mpiBWAIdx

`mpiBWAIdx` is responsible for creating a binary image of the reference genome. This image is subsequently loaded in shared memory by `mpiBWA`. Then every `mpiBWA` process on the computing node will share the same genome reference. mpiBWAIdx deos'nt need MPI to run. To create an image type:

`mpiBWAIdx my_ref.fa` this will create the file `my_ref.fa.map`. `mpiBWAIdx` requires the following files `my_ref.fa.sa`, `my_ref.fa.bwt`, `my_ref.fa.ann`, `my_ref.fa.pac`, `my_ref.fa.amb` to construct the `fa.map` file. Those file are generated by `bwa index`. It works also with the fasta.

See [genome.sh](examples/genome.sh) script to build the map file.

`mpiBWA` is executed with the `mpirun` program, for example:

`mpirun -n 1 mpiBWA mem -t 8 -o $SAM_OUT $REFERENCE $FASTQ1 $FASTQ2` will launch 1 process MPI and 8 threads will be created by mpiBWA.

Do not write the extension .map for the reference. If the file is `my_ref.fa.map` pass `my_ref.fa` to `mpiBWA`. 

The `-n` options passed to `mpirun` indicates the number of processes to run in parallel (this is basically the number of cores that will be used). For for details on how to choose the number processes, see the [Informatic resources](#informatic-resources) section.

`mpiBWA` requires four mandatory arguments:

* [Input](#input): a reference genome in .map format, one or two fastq files trimmed or not 
* [Output](#output): a sam file 

If you decide to split by chromosom the output SAM file you give will contain the header, and for each chromosome of the header mpiBWA will yield a SAM file plus a discordant and a unmapped SAM files.

## Informatic resources

### Memory

The total memory used during the alignment if approximately the size of the .map plus the size of the sam loaded by each bwa tasks. A BWA threads consume around 300 MB.
 
### CPU 

The number of CPU is related to the number of rank of the MPI jobs and to the number of threads you ask with BWA and with the -t option.

## Examples

### Standard

`mpirun` can be launched in a standard manner without using any job scheduling systems. For example:

`mpirun -n 4 mpiBWA mem -t 8 -o ${HOME}/mpiBWAExample/example.sam ${MYREF} examples/data/HCC1187C_R1_10K.fastq examples/data/HCC1187C_R2_10K.fastq `

If needed, a file with the server name in `-host` option can be provided to `mpirun`. We invite you to read the `mpirun` documentation for more details.


### Slurm

```shell
#! /bin/bash
#SBATCH -J MPIBWA_32_JOBS
#SBATCH -N 2                            # Ask 2 nodes
#SBATCH -n 4                            # Total number of cores
#SBATCH -c 8                            # use 8 core per mpi job
#SBATCH --tasks-per-node=2              # Ask 2 cores per node
#SBATCH --mem-per-cpu=${MEM}            # See Memory ressources
#SBATCH -t 01:00:00
#SBATCH -o STDOUT_FILE.%j.o
#SBATCH -e STDERR_FILE.%j.e

mpirun mpiBWA mem -t 8 -o ${HOME}/mpiBWAExample/example.sam ${MYREF} examples/data/HCC1187C_R1_10K.fastq examples/data/HCC1187C_R2_10K.fastq

```

### PBS/Torque

```shell
#! /bin/bash
#PBS -N MPIBWA_32_JOBS
#PBS -l nodes=2:ppn=16:mem=${MEM}        # Ask 2 nodes and 16 jobs per node
#PBS -l walltime=24:00:00
#PBS -o STDOUT_FILE.%j.o
#PBS -e STDERR_FILE.%j.e

mpirun mem -t 8 -o ${HOME}/mpiBWAExample/example.sam ${MYREF} examples/data/HCC1187C_R1_10K.fastq examples/data/HCC1187C_R2_10K.fastq

```


## Performance

This parallel version of BWA MEM is meant to be 100% reproducible with original BWA MEM version. It means if you took the same number of threads in the serial version and in the MPI version you will obtain exactly the same results.

Heres an example of the scalability tests we realize with the TGCC (Tres Grand Centre de Calcul - Bruyeres le Chatel - France)  

![img](Results_TGCC_Broadwell.jpg)



## Parallel filesystems

This software need a parallel file system for execution. The programm has been tested with Lustre and Beegfs.

WARNING: 

Be aware of the flock mode on parallel file system (Lustre, Beegfs): flock must be on. Otherwise reproducibility is not guaranteed. 


## Algorithm

The algorithm is divided in 3 sections.

In the first section MPI jobs are responsible for creating chunks of reads. All those chunks contain the same number of nucleotids.

In the second section MPI jobs calls aligner jobs. This part invokes BWA MEM algorithm.

In the third section MPI jobs write the alignment results in a SAM file or in individual chromosom SAM files. This part uses shared file pointers.

## References

This work is based on the original bwa aligner written by Li et al.

Li H. and Durbin R. (2010) Fast and accurate long-read alignment with Burrows-Wheeler transform. Bioinformatics, 26, 589-595. [PMID: 20080505]

Li H. (2013) Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM. arXiv:1303.3997v1 [q-bio.GN]

Latham R. et al. (2007) Implementing MPI-IO Atomic Mode and Shared File Pointers Using MPI One-Sided Communication











